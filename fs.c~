#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<malloc.h>
#define NUM_OF_DATA_dblock 9913
#define NUM_OF_INODE 10240
#define INODE_TABLE_SIZE 320 
#define TOTAL_dblock 10240
#define BLOCK_SIZE 4096		 
#define DIRECTORY_SIZE 10		
char cmdprompt[30];

typedef struct datablock
{
  unsigned int dblock[10];
}DataBlock;

typedef struct diskinode{
  int inum;
  int type;     	
  int number_of_dblock;     
  unsigned int size;        
  DataBlock db;           
  DataBlock *idb;          
  short int d_link;
  char iname[16];
  char future_use[48];
}DiskInode;

typedef struct dir{
  short int inum;
  short int lname;
  char fname[16];
}MyDir;

MyDir currentDir;

typedef struct superblock
{
	char free_block_list[NUM_OF_DATA_dblock];
  	char free_inode_list[NUM_OF_INODE];
  	int fs_size;
  unsigned int no_of_free_dblock;
  unsigned int disk_inode_list_size;
  unsigned int no_of_free_inodes_disk;
  	   int flag;
  	   int root_index;
 
}SuperBlock;
SuperBlock sb;

void mountFS(int sizeinmb,int blksize)
{
	FILE *fp,*fp1;
	  
	int i,j;
	int no_of_inodes,size_on_disk_inodes,size_on_disk_blk,size_of_inodestruct;
	  
	DiskInode di[NUM_OF_INODE];
	MyDir rt;
	  
	fp1 = fopen("devfs","r+");
  	if(!fp1)
	{
	    printf("\n Error : Unable to MOUNT ");
	    exit(1);
	}
	fread(&sb,sizeof(struct superblock),1,fp1);
	printf("%d",sb.fs_size);
	if(sb.fs_size==0)
	{
		fp = fopen("devfs","w+");
		
		sb.fs_size = sizeinmb*1024*1024;
		sb.no_of_free_dblock = NUM_OF_DATA_dblock;		
		sb.no_of_free_inodes_disk = NUM_OF_INODE;		
		size_on_disk_inodes = sb.no_of_free_inodes_disk   / blksize;
		size_on_disk_blk    = sb.no_of_free_dblock / blksize;
		size_of_inodestruct = sb.no_of_free_inodes_disk*128 / blksize;
		sb.disk_inode_list_size = INODE_TABLE_SIZE;
		printf("\nsize in mb for File System = %f\n", (float)(24+(size_on_disk_inodes+size_on_disk_blk+size_of_inodestruct)*blksize)/(1024*1024));  

	  	
		
		i=0;  	
		sb.free_block_list[i] = '1';
		for(i=1;i<sb.no_of_free_dblock;i++)    
		{
			sb.free_block_list[i] = '0';
		
		}
	
		i=0;
		sb.free_inode_list[i] = '1';
		for(i=1;i<sb.no_of_free_inodes_disk;i++)    
		{
			sb.free_inode_list[i] = '0';
		
		}
	
		sb.no_of_free_dblock--;	
		sb.no_of_free_inodes_disk--;
		sb.root_index=1;		
			
		fwrite(&sb,sizeof(struct superblock),1,fp);
			
		i=0;
		di[i].inum=1;		
		strcpy(di[i].iname,"root");		
		di[i].type=1;
		di[i].number_of_dblock=1;
		di[i].size=40;
		di[i].d_link=0;
		di[i].db.dblock[0]=0;	
		for(j=1;j<10;j++)
			di[i].db.dblock[j]=-1;
		di[i].idb=NULL;
		for(j=0;j<48;j++)
			di[i].future_use[j]='\0';
		
		fwrite(&di[i],sizeof(struct diskinode),1,fp);
		
		
		for(i=1;i<NUM_OF_INODE;i++)    
		{
			di[i].inum=i+1;
			strcpy(di[i].iname,"\0");	
			di[i].type=-1;
			di[i].number_of_dblock=0;
			di[i].size=0;
			di[i].d_link=0;
		
		

			for(j=0;j<10;j++)
			{
				di[i].db.dblock[j]=-1;
			
			}
			di[i].idb=NULL;
		
			for(j=0;j<48;j++)
				di[i].future_use[j]='\0';
		
			fwrite(&di[i],sizeof(struct diskinode),1,fp);
		}
	
		
		rt.inum=1;
		rt.lname=1;
		strcpy(rt.fname,".");		
		fwrite(&rt,sizeof(struct dir),1,fp);

		rt.inum=1;
		rt.lname=2;
		strcpy(rt.fname,"..");		
		fwrite(&rt,sizeof(struct dir),1,fp);
	
		fseek(fp,(blksize-(sizeof(struct dir)*2)),SEEK_CUR);		
		
		for(i=0;i<9912*4096;i++)
		{
			fprintf(fp,"%c",'\0');
		}
		printf("\nFILE INITIALIZED\n");
		fclose(fp);
	}
	else
		printf("\nFILE LOADED\n");
		fclose(fp1);
}

int inodealloc()
{
	int i;
	FILE *disk; 
	disk = fopen("devfs","r+");
	
	fread(&sb,sizeof(struct superblock),1,disk);
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}

	if(sb.no_of_free_inodes_disk==0)
	{
		fclose(disk);	
		return -1;
	}
	for(i=0;i<NUM_OF_INODE;i++)
		if(sb.free_inode_list[i]=='0')
		{
			sb.no_of_free_inodes_disk--;
			sb.free_inode_list[i]='1';
			fseek(disk,0L,SEEK_SET);			
			fwrite(&sb,sizeof(struct superblock),1,disk);		
			fclose(disk);
			return i+1;	   		
		}
}

int alloc()
{

	int i;
	FILE *disk; 
	disk = fopen("devfs","r+");
	
	fread(&sb,sizeof(struct superblock),1,disk);
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}

	if(sb.no_of_free_dblock==0)
	{
		fclose(disk);	
		return -1;
	}
	for(i=0;i<NUM_OF_DATA_dblock;i++)
		if(sb.free_block_list[i]=='0')
		{
			sb.no_of_free_dblock--;
			sb.free_block_list[i]='1';		
			fseek(disk,0L,SEEK_SET);			
			fwrite(&sb,sizeof(struct superblock),1,disk);
			fclose(disk);
			return i;	 		
		}
}

int inodefree(int inum)
{	
	FILE *disk; 
	disk = fopen("devfs","r+");
	
	fread(&sb,sizeof(struct superblock),1,disk);
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}
								  
	sb.no_of_free_inodes_disk++;		
	sb.free_inode_list[inum-1]='0';	
	fseek(disk,0L,SEEK_SET);	
	fwrite(&sb,sizeof(struct superblock),1,disk);
	fclose(disk);
	return 0;		
}

int datafree(int i)
{
	FILE *disk; 
	disk = fopen("devfs","r+");
	
	fread(&sb,sizeof(struct superblock),1,disk);
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}
	sb.no_of_free_dblock--;		
	sb.free_block_list[i]='1';		
	fseek(disk,0L,SEEK_SET);
	fwrite(&sb,sizeof(struct superblock),1,disk);
	fclose(disk);
	return 0;
}



int mycreat(char *filename ,int curinode)
{
	int i,j,newinode,newdb;
	long int loc1,loc2;
	FILE *disk;
	MyDir dir;
	DiskInode di,new;
		
	disk = fopen("devfs","r+");
	
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}
	
	
	newinode=inodealloc();
	newdb=alloc();
	if(newinode==-1)
	{
		printf("\nError: Unable to create file");
		return;
	}
	if(newdb==-1)
	{
		printf("\nError: Unable to create file, insufficient memory ");
		return;
	}
	
	loc1=((curinode-1)*128)+20180;
	fseek(disk,loc1,SEEK_SET);
	fread(&di,sizeof(struct diskinode),1,disk);
	
	
	loc2=(di.db.dblock[0]*4096)+1330900+di.size;
	
	fseek(disk,loc2,SEEK_SET);
	dir.inum=newinode;
	dir.lname=strlen(filename);
	strcpy(dir.fname,filename);
	fwrite(&dir,sizeof(struct dir),1,disk);	 

	di.size+=sizeof(struct dir);	
	fseek(disk,loc1,SEEK_SET);
	fwrite(&di,sizeof(struct diskinode),1,disk);	
	loc1=((newinode-1)*128)+20180;	

	fseek(disk,loc1,SEEK_SET);
	new.inum=newinode;		
	strcpy(new.iname,filename);		
	new.type=2;	
	new.number_of_dblock=1;
	new.size=0;	
	new.d_link=0;
	new.db.dblock[0]=newdb;
	for(j=1;j<10;j++)
		new.db.dblock[j]=-1;
	new.idb=NULL;
	for(j=0;j<48;j++)
		new.future_use[j]='\0';

	fwrite(&new,sizeof(struct diskinode),1,disk);
	
	fclose(disk);
	return newinode;
}

int mymkdir(char *filename, int curinode)
{

	int i,j,newinode,newdb;
	long int loc1,loc2;
	FILE *disk;
	MyDir dir;
	DiskInode di,new;
	disk = fopen("devfs","r+");
	
  	if(!disk)
	{
	    printf("\nError: Unable to MOUNT ");
	    return -1;
	}
	
	fread(&sb,sizeof(struct superblock),1,disk);	
	fseek(disk,0L,SEEK_SET);

	if(FileS_namei(filename,curinode) !=curinode)
	{
		printf("Error: File or directory name already exists");
		return -1;		
	}  

	newinode=inodealloc();
	newdb=alloc();
	
	if(newinode==-1)
	{
		printf("\nError: Unable to create file");
		return -1;
	}
	if(newdb==-1)
	{
		printf("\nError: Unable to create file, insufficient memory ");
		return -1;
	}

	loc1=((curinode-1)*128)+20180;
	fseek(disk,loc1,SEEK_SET);
	fread(&di,sizeof(struct diskinode),1,disk);
	loc2=(di.db.dblock[0]*4096)+1330900+di.size;	
	fseek(disk,loc2,SEEK_SET);
	dir.inum=newinode;
	dir.lname=strlen(filename);
	strcpy(dir.fname,filename);
	fwrite(&dir,sizeof(struct dir),1,disk);	

	di.size+=sizeof(struct dir);	
	fseek(disk,loc1,SEEK_SET);
	fwrite(&di,sizeof(struct diskinode),1,disk);	
	
	loc1=((newinode-1)*128)+20180;
	fseek(disk,loc1,SEEK_SET);
	new.inum=newinode;		
	strcpy(new.iname,filename);		
	new.type=1;	
	new.number_of_dblock=1;
	new.size=40;	
	new.d_link=0;
	new.db.dblock[0]=newdb;	
	for(j=1;j<10;j++)
		new.db.dblock[j]=-1;
	new.idb=NULL;
	for(j=0;j<48;j++)
		new.future_use[j]='\0';
	fwrite(&new,sizeof(struct diskinode),1,disk);		

	loc2=(newdb*4096)+1330900;
	fseek(disk,loc2,SEEK_SET);

	dir.inum=newinode;
	dir.lname=1;
	strcpy(dir.fname,".");
	fwrite(&dir,sizeof(struct dir),1,disk);	

	dir.inum=curinode;		
	dir.lname=2;
	strcpy(dir.fname,"..");	
	fwrite(&dir,sizeof(struct dir),1,disk);	

	fclose(disk);
	return newinode;
	
}

int FileS_namei(char path[30],int cur_inode)
{
	int cur_inum=-1,blk_pos,i,j,k,flg=0;
	char temp[10][30];
	DiskInode di[NUM_OF_INODE];
	MyDir dir;
	FILE *fp;	
	fp = fopen("devfs","r");
  	
	if(!fp)
	{
	    printf("\nError: Unable to MOUNT ");
	    exit(1);
	}
	if(strcmp(path,"/")==0)
		return sb.root_index;
	if(path[0]=='/')
	{
		for(i=1,k=0,j=0;path[i]!='\0';i++)
		{
			if(path[i]=='/')
			{
				temp[k][j]='\0';
				k++;
				j=0;
				
			}
			else
			temp[k][j++]=path[i];
		}
		temp[k][j]='\0';
		
		cur_inum=sb.root_index;

		
		j=0;		
		while(1)
		{
			fseek(fp,20180L+(cur_inum-1)*128,SEEK_SET); 
			fread(&di[cur_inum-1],sizeof(struct diskinode),1,fp);
		
			blk_pos=di[cur_inum-1].db.dblock[0];
			fseek(fp,1330900+blk_pos*4096,SEEK_SET);
			

			
			do{
				i=fread(&dir,sizeof(MyDir),1,fp);
								
				if(strlen(dir.fname)==0)
				{
					flg=1;
					break;
				}				
				if(strcmp(dir.fname,temp[j])==0)
				{	
					flg=0;
					break;
				}
													
			}while(1);	
			if(flg==1)
			{
				
				return cur_inode;
			}
			if(flg==0)
				cur_inum=dir.inum;
			j++;
			if(j>k)
			{
				
				return cur_inum;
			}
		}					
	}
	else
	{
	for(i=0,k=0,j=0;path[i]!='\0';i++)
		{
			if(path[i]=='/')
			{
				temp[k][j]='\0';
				k++;
				j=0;
				
			}
			else
			temp[k][j++]=path[i];
		}
		temp[k][j]='\0';
		cur_inum=cur_inode;
		j=0;		
		while(1)
		{
			fseek(fp,20180L+(cur_inode-1)*128,SEEK_SET); 	
			fread(&di[cur_inode-1],sizeof(struct diskinode),1,fp);
		
			blk_pos=di[cur_inode-1].db.dblock[0];
			fseek(fp,1330900+blk_pos*4096,SEEK_SET);
			

			
			do{
				i=fread(&dir,sizeof(MyDir),1,fp);
								
				if(strlen(dir.fname)==0)
				{
					flg=1;
					break;
				}				
				if(strcmp(dir.fname,temp[j])==0)
				{	
					flg=0;
					break;
				}
													
			}while(1);	
			if(flg==1)
			{
				
				return cur_inum;
			}			
			if(flg==0)
				cur_inode=dir.inum;
			j++;
			if(j>k)
			{
				
				return cur_inode;
			}
		}				
	
	}		

}
void change_directory(char path[30],int cur_inode)
{
	int blk_pos;
	MyDir dir;
	char par[20],child[20],slash[30];
	DiskInode di[NUM_OF_INODE];	
	cur_inode=FileS_namei(path,cur_inode);
		
	FILE *fp;	
	fp = fopen("devfs","r");
  	
	if(!fp)
	{
	    printf("\nError: Unable to MOUNT ");
	    exit(1);
	}
	
	if(cur_inode==-1)
	{
	
	}
	else
	{

		child[0]='\0';
		
		while(1)
		{
			strcpy(slash,"/");
			fseek(fp,20180L+(cur_inode-1)*128,SEEK_SET); 	// 20180 start of Inode list, +128 for next Inode structure
				
			fread(&di[cur_inode-1],sizeof(DiskInode),1,fp);

			
			if(di[cur_inode-1].type!=1)
			{
				printf("\nInvalid directory\n");
				break;

			}
			strcpy(par,di[cur_inode-1].iname);
			
			strcat(slash,par);
			strcpy(par,slash);
			strcat(par,child);
			strcpy(child,par);
			blk_pos=di[cur_inode-1].db.dblock[0];
			
			
			
			fseek(fp,1330900+blk_pos*4096+sizeof(MyDir),SEEK_SET);
			
			fread(&dir,sizeof(MyDir),1,fp);	
	
			
			
			cur_inode=dir.inum;
			
			if(cur_inode==1)
				break;			
		}
		
		strcpy(par,"root");
		strcat(par,child);
		strcpy(cmdprompt,par);	

	}	
}
void list(int cur_inode)
{
	int blk_pos,blk1;
	MyDir dir;
	char par[20],child[20],slash[30];
	DiskInode di[NUM_OF_INODE],td;	
	FILE *fp,*fp1;	
	fp = fopen("devfs","r");
  	
	if(!fp)
	{
	    printf("\nError: Unable to MOUNT ");
	    exit(1);
	}
		fseek(fp,20180L+(cur_inode-1)*128,SEEK_SET); 	
		
		
		
			fread(&di[cur_inode-1],sizeof(struct diskinode),1,fp);
		
			blk_pos=di[cur_inode-1].db.dblock[0];
			fseek(fp,1330900+blk_pos*4096,SEEK_SET);
			

			printf("Name\t\tInode\ttype\n-------------------------------------");
			do{
				fread(&dir,sizeof(MyDir),1,fp);
				if(strlen(dir.fname)==0)
				{
					break;
				}

				printf("\n%s \t\t%d",dir.fname,dir.inum);
				fp1 = fopen("devfs","r");
				fseek(fp1,20180L+(dir.inum-1)*128,SEEK_SET);	
				fread(&td,sizeof(struct diskinode),1,fp1);			
				printf("\t%d",td.type);
				fclose(fp1);
																	
			}while(1);	
		

}

int myremove(char *filename, int curinode)		
{
	int i,j,inode,n;
	long int loc1,loc2;
	FILE *disk,*disk1;

	MyDir new,dir,blank;
	DiskInode di,cur;
		
       	if(strcmp(filename,"..")==0 || strcmp(filename,".")==0)
	{
		printf("\nError: cannot remove '%s': Is a directory",filename);		
		return -1;
	}

	inode= FileS_namei(filename,curinode); 
	if(inode==-1)
		{
			printf("\nError: cannot remove : No such file or directory");
			return -1;		
		}

  disk = fopen("devfs","r+");

  if(!disk)
    {
      printf("\nError: Unable to MOUNT ");
      return -1;
    }
	
	loc1=((inode-1)*128)+20180;
  	fseek(disk,loc1,SEEK_SET);
  	fread(&di,sizeof(struct diskinode),1,disk);
	if(di.type!=2)
	{
		printf("\nError: File is not regular file, unable to delete");		
		return -1;
	}	
	printf("\nDo you want to remove regular file '%s'? (y/n) ",filename);
	fflush(NULL);	
	if(getchar()=='y')
		{
	 		n=di.number_of_dblock;
			for(i=0;i<n;i++)
				datafree(di.db.dblock[i]);
			inodefree(inode); 
			loc1=((curinode-1)*128)+20180;
 			fseek(disk,loc1,SEEK_SET);
  		fread(&cur,sizeof(struct diskinode),1,disk);
			loc2=(cur.db.dblock[0]*4096)+1330900;
  		fseek(disk,loc2,SEEK_SET);	
			
			
	
			blank.inum=-1;
			blank.lname=0;
			strcpy(blank.fname,"\0");
			while(1)
			{				
				fread(&dir,sizeof(struct dir),1,disk);
				if(dir.inum==inode)				
				{
					

					while(1)
					{
						fread(&dir,sizeof(struct dir),1,disk);
						
							fseek(disk,-40L,SEEK_CUR);
							fwrite(&dir,sizeof(struct dir),1,disk);
							fwrite(&blank,sizeof(struct dir),1,disk);
							
						if(dir.lname==0)
							break;
					}
					cur.size=cur.size-20;
										
					loc1=((curinode-1)*128)+20180;
				 	fseek(disk,loc1,SEEK_SET);
		  			fwrite(&cur,sizeof(struct diskinode),1,disk);
					
					fclose(disk);
					return 0;
				}		
			}
		}
		fclose(disk);
		return 0;							
}
int myremovedir(char *filename, int curinode)
{
	int i,j,inode,n;
  long int loc1,loc2;
  FILE *disk,*disk1;
  
  MyDir new,dir,blank;
  DiskInode di,cur;
	if(strcmp(filename,"..")==0 || strcmp(filename,".")==0)
	{
		printf("\nError: failed to remove '%s': Directory not empty",filename);		
		return -1;
	}

	inode= FileS_namei(filename,curinode);
	 
	if(inode==-1)
		{
				printf("\nError: cannot remove : No such file or directory");
				return -1;		
		}  

	disk = fopen("devfs","r+");
  if(!disk)
    {
      printf("\nError: Unable to MOUNT ");
      return -1;
    }
	  
			

	loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fread(&di,sizeof(struct diskinode),1,disk);
	if(di.type!=1)
	{
		printf("\nError: File is not a directory file, unable to delete");		
		fclose(disk);		
		return -1;
	}	
	if(di.size>40)
	{
		printf("\nError: failed to remove '%s': Directory not empty",filename);		
		fclose(disk);
		return -1;
	}
 	n=di.number_of_dblock;
	for(i=0;i<n;i++)
		datafree(di.db.dblock[i]);
	inodefree(inode); 
	loc1=((curinode-1)*128)+20180;
	fseek(disk,loc1,SEEK_SET);
 	fread(&cur,sizeof(struct diskinode),1,disk);
	loc2=(cur.db.dblock[0]*4096)+1330900;
 	fseek(disk,loc2,SEEK_SET);	

	
			blank.inum=-1;
			blank.lname=0;
			strcpy(blank.fname,"\0");
			
			while(1)
			{				
				fread(&dir,sizeof(struct dir),1,disk);
				if(dir.inum==inode)				
				{
					

					while(1)
					{
						fread(&dir,sizeof(struct dir),1,disk);
						
						fseek(disk,-40L,SEEK_CUR);
						fwrite(&dir,sizeof(struct dir),1,disk);
						fwrite(&blank,sizeof(struct dir),1,disk);
						if(dir.lname==0)
							break;
					}
					cur.size=cur.size-20;
					
					
					loc1=((curinode-1)*128)+20180;
				 	fseek(disk,loc1,SEEK_SET);
		  			fwrite(&cur,sizeof(struct diskinode),1,disk);
					

					fclose(disk);
					return 0;
				}		
	
			}
}

int mywrite(int inode)
{
  int i,j,fs,n,k;
  long int loc1,loc2;
  char buff[4096];
  FILE *disk;
  MyDir dir;
  DiskInode di,new;
	
  disk = fopen("devfs","r+");
	
  if(!disk)
    {
      printf("\nError: Unable to MOUNT ");
      return -1;
    }
	
  loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fread(&di,sizeof(struct diskinode),1,disk);
 

  k=0;
  loc2=(di.db.dblock[k]*4096)+1330900;
  fseek(disk,loc2,SEEK_SET);
  printf("\nEnter Data:\n");
  i=0;	
  while(1)
    {
      buff[i]=getchar();
      if(buff[i]==EOF)
				break;	
      i++;		
      if(i==4096)
			{	
			  loc2=(di.db.dblock[k]*4096)+1330900;
			  fseek(disk,loc2,SEEK_SET);
			  fwrite(&buff,4096,1,disk);
			  k++;			
			  j=alloc();
			  if(j==-1)
			    {
			      printf("\nError: Unable to create file, insufficient memory ");
			      return -1;
			    }
			  di.db.dblock[k]=j;
			  di.number_of_dblock++;
			}				
 		}
  loc2=(di.db.dblock[k]*4096)+1330900;
  fseek(disk,loc2,SEEK_SET);	
  fwrite(&buff,i,1,disk);	
	
  di.size=(k*4096)+i;	
  loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fwrite(&di,sizeof(struct diskinode),1,disk);
 
	
  fclose(disk);
  return 0;

}

int myappend(int inode)
{
  int i,j,fs,n,k;
  long int loc1,loc2;
  char buff[4096];
  FILE *disk;
  MyDir dir;
  DiskInode di,new;
	
  disk=fopen("devfs","r+");
	
  if(!disk)
    {
      printf("\nError: Unable to MOUNT ");
      return -1;
    }
	
  loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fread(&di,sizeof(struct diskinode),1,disk);
  

  k=di.number_of_dblock;
	k--;  
	fs=di.size;
	n= fs%4096;
	printf("%d",n);	
	loc2=(di.db.dblock[k]*4096)+1330900;	
	fseek(disk,loc2,SEEK_SET);
	fread(&buff,4096,1,disk);  
	printf("\nEnter Data to append:\n");
  i=n;	
  while(1)
    {
      buff[i]=getchar();
      if(buff[i]==EOF)
				break;	
      i++;		
      if(i==4096)
			{	
			  loc2=(di.db.dblock[k]*4096)+1330900;
			  fseek(disk,loc2,SEEK_SET);
			  fwrite(&buff,4096,1,disk);
			  k++;			
			  j=alloc();
			  if(j==-1)
			    {
			      printf("\nError: Unable to create file, insufficient memory ");
				    return -1;
	    		}
	  		di.db.dblock[k]=j;
	  		di.number_of_dblock++;
			}
		}
  loc2=(di.db.dblock[k]*4096)+1330900;
  fseek(disk,loc2,SEEK_SET);	
  fwrite(&buff,i,1,disk);	
	
  di.size=(k*4096)+i;	
  loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fwrite(&di,sizeof(struct diskinode),1,disk);
  
	fclose(disk);
  return 0;
}

int myread(int inode)
{
  int i,j;
  long int loc1,loc2;
  char buff,buff1[4096];
  FILE *disk;
  MyDir dir;
  DiskInode di,new;
  int fs=0,n=0;

  disk = fopen("devfs","r+");
	
  if(!disk)
    {
      printf("\nError: Unable to MOUNT ");
      return -1;
    }
	
  loc1=((inode-1)*128)+20180;
  fseek(disk,loc1,SEEK_SET);
  fread(&di,sizeof(struct diskinode),1,disk);
  if(di.size==0)
    {
      printf("Error: File is Empty!!");
      return 0;
    }
  printf("\nData:\n");
  fs=di.size;
  n=di.number_of_dblock;
  j = 0;	
	
  if(n==1)
    {
      loc2=(di.db.dblock[j]*4096)+1330900;
      fseek(disk,loc2,SEEK_SET);
			
      for(i=0;i<fs;i++)
	{
	  fread(&buff,1,1,disk);	
	  printf("%c",buff);
	}
    }
  else
    {
      for(j=0;j<n-1;j++)
	{
	  loc2=(di.db.dblock[j]*4096)+1330900;
	  fseek(disk,loc2,SEEK_SET);	
	  fread(&buff1,4096,1,disk);	
	  printf("%s",buff1);
	  fs-=4096;
	}			
      loc2=(di.db.dblock[j]*4096)+1330900;
      fseek(disk,loc2,SEEK_SET);
      for(i=0;i<fs;i++)
	{
	  fread(&buff,1,1,disk);	
	  printf("%c",buff);
	}	
    }

  fclose(disk);
  return 0;
}

int myopen(char *filename ,int curinode)
{
  int inode;
  inode=FileS_namei(filename,curinode);
	if(inode==-1)
		{
				printf("Error: File or directory name already exists");
				return -1;		
		}  
	return inode;
}

int main()
{
	FILE *fp;	
	int size=40,blk=BLOCK_SIZE,i=0,n,cur_inode=1;
	char cmd[40],s1[20],s2[20];
	
	fp = fopen("devfs","r+");
  	if(!fp)
	{
	    printf("\nError: Unable to MOUNT ");
	    exit(1);
	}
	
	fread(&sb,sizeof(struct superblock),1,fp);
	
	mountFS(size,blk);
	strcpy(cmdprompt,"MY_PROMPT");
	printf("\nType 'help' for any help\n");
	while(1)
	{
		printf("\n\n%s :=",cmdprompt);
		gets(cmd);
		n=sscanf(cmd,"%s%s",s1,s2);
		
		switch(n)
		{
			case 1:{
					if(strcmp(s1,"ls")==0)
					{	list(cur_inode);
						break;
					}
					if(strcmp(s1,"exit")==0)
					{	
						exit(0);
					}
					if(strcmp(s1,"FORMAT")==0)
					{	
						printf("\nARE YOU SURE(y/n):-");
						if(getchar()=='y')
						{
							fp = fopen("devfs","w+");
							sb.fs_size=0;
							fwrite(&sb,sizeof(SuperBlock),1,fp);
							mountFS(size,blk);
							
						}
						break;
					}
					if(strcmp(s1,"help")==0)
					{	
						printf("\nls 			:= list all files in current directory");
						printf("\nmkdir <dir name> 	:= create new directory in current directory");
						printf("\nrmdir <dir name> 	:= remove directory from current directory");
						printf("\ncreat <filename> 	:= create new file in current directory");
						printf("\nrm <filename> 	:= remove file from current directory");
						printf("\ncd <path> 		:= set pointer in end file in path ");
						printf("\nFORMAT		 	:= format the whole file system");
						printf("\nexit		 	:= exit the shell");
					
						break;
					}
				
				}
			case 2:
				{
					if(strcmp(s1,"open")==0)
					{	
						
						printf("\nInode allocated= %d",myopen(s2,cur_inode));
						break;
					}

					if(strcmp(s1,"read")==0)
					{	
						printf("\n%d\n",atoi(s2));
						myread(atoi(s2));
						break;
					}
			
					if(strcmp(s1,"write")==0)
					{	
						
						mywrite(atoi(s2));
						break;
					}
					if(strcmp(s1,"append")==0)
					{	
						
						printf("\nInode allocated= %d",myappend(atoi(s2)));
						break;
					}


					if(strcmp(s1,"creat")==0)
					{	
						
						printf("\nInode allocated= %d",mycreat(s2,cur_inode));
						break;
					}

					if(strcmp(s1,"mkdir")==0)
					{
						printf("\nInode allocated=%d",mymkdir(s2,cur_inode));
						break;								
					}
					if(strcmp(s1,"rm")==0)
					{
						myremove(s2,cur_inode);
						break;

					}
					if(strcmp(s1,"rmdir")==0)
					{
						myremovedir(s2,cur_inode);
						break;						
					}
					if(strcmp(s1,"cd")==0)
					{	change_directory(s2,cur_inode);
						cur_inode=FileS_namei(s2,cur_inode);
						break;
					}		
				}
		}	
		strcpy(s1,"");
		strcpy(s2,"");
	}		
	return 0;
}
